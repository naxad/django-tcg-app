# grading/openai_client.py
from __future__ import annotations

import base64
import io
import json
import mimetypes
import os
from pathlib import Path
from typing import Dict, Optional, Any, Tuple, List

import cv2
import numpy as np
from PIL import Image
from openai import OpenAI

from grading.ml.vision_checks import run_vision_checks_img

# ---------------------------
# Config
# ---------------------------
OPENAI_MODEL_GRADE = os.getenv("OPENAI_GRADING_MODEL", "gpt-4o")
OPENAI_MODEL_CLASS = os.getenv("OPENAI_CLASSIFIER_MODEL", "gpt-4o-mini")
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")

REQUIRE_FRONT_FIRST = True

# CV blending (keep OFF until you train on more data)
BLEND_CV_ALPHA = float(os.getenv("CV_BLEND_ALPHA", "0.0"))  # 0.0 = disabled
CV_WEIGHTS = os.getenv("CARDGRADER_WEIGHTS", "grading/ml/models/cardgrader_v1.pt")

# Path to your transparent PNG set symbols (you said you added them)
# You can override with env POKEMON_SET_SYMBOLS_DIR
SET_SYMBOLS_DIR = os.getenv(
    "POKEMON_SET_SYMBOLS_DIR",
    "grading/assets/set_symbols"  # put your PNGs here (filenames become symbol IDs)
)

# Template matching sensitivity (tweakable)
SYMBOL_MIN_CONF = float(os.getenv("POKEMON_SYMBOL_MIN_CONF", "0.62"))
SYMBOL_TARGET_H = int(os.getenv("POKEMON_SYMBOL_TARGET_H", "60"))  # template normalized height (px)

client = OpenAI(api_key=OPENAI_API_KEY)

# ---------------------------
# Game back references (for the game-aware prompt)
# ---------------------------
GAME_BACK_RULES = {
    "pokemon": "Back reference: blue background with Poké Ball and 'Pokémon' logo.",
    "one_piece": "Back reference: mostly blue (sometimes white or red) with 'ONE PIECE CARD GAME' text and a compass design.",
    "mtg": "Back reference: brown/sepia oval with five colored mana orbs and 'Magic: The Gathering'.",
}

GAME_LABELS = {
    "pokemon": "Pokémon",
    "one_piece": "One Piece",
    "mtg": "Magic: The Gathering",
}

# ---------------------------
# Set-code → style/era map (YOU CAN EXTEND THIS)
# ---------------------------
# Matching is case-insensitive. Keys can be exact codes (e.g., "sv2a", "TEF EN")
# or normalized tokens (e.g., "sv2a", "tef", "pre en"). We normalize by removing
# punctuation and collapsing spaces. You can add hundreds here safely.
#
# Fields you can use per entry:
#   set_name: human-friendly set name
#   era:      e.g., "Base/WotC", "EX", "DP", "XY", "SM", "SWSH", "SV"
#   border:   e.g., "yellow", "silver", "black", "gold", "e-reader yellow"
#   language: "en", "jp", or "other"
SET_CODE_MAP: Dict[str, Dict[str, str]] = {
    # ---- Scarlet & Violet era (examples) ----
    "svi en": {"set_name": "Scarlet & Violet", "era": "SV", "border": "silver", "language": "en"},
    "pal en": {"set_name": "Paldea Evolved", "era": "SV", "border": "silver", "language": "en"},
    "obf en": {"set_name": "Obsidian Flames", "era": "SV", "border": "silver", "language": "en"},
    "par en": {"set_name": "Paradox Rift", "era": "SV", "border": "silver", "language": "en"},
    "sv2a":   {"set_name": "Pokémon 151 (JP)", "era": "SV", "border": "silver", "language": "jp"},
    "tef en": {"set_name": "Temporal Forces", "era": "SV", "border": "silver", "language": "en"},
    "twm en": {"set_name": "Twilight Masquerade", "era": "SV", "border": "silver", "language": "en"},
    "sfa en": {"set_name": "Shrouded Fable", "era": "SV", "border": "silver", "language": "en"},
    "scr en": {"set_name": "Stellar Crown", "era": "SV", "border": "silver", "language": "en"},
    "ssp en": {"set_name": "Surging Sparks", "era": "SV", "border": "silver", "language": "en"},
    "pre en": {"set_name": "Prismatic Evolutions", "era": "SV", "border": "silver", "language": "en"},
    # ---- Sword & Shield era (examples) ----
    "ssh en": {"set_name": "Sword & Shield", "era": "SWSH", "border": "yellow", "language": "en"},
    "evs en": {"set_name": "Evolving Skies", "era": "SWSH", "border": "yellow", "language": "en"},
    "brs en": {"set_name": "Brilliant Stars", "era": "SWSH", "border": "yellow", "language": "en"},
    # ---- Sun & Moon era (examples) ----
    "sum en": {"set_name": "Sun & Moon", "era": "SM", "border": "yellow", "language": "en"},
    "cec en": {"set_name": "Cosmic Eclipse", "era": "SM", "border": "yellow", "language": "en"},
    # ---- XY era (examples) ----
    "evo en": {"set_name": "Evolutions", "era": "XY", "border": "yellow", "language": "en"},
    # ---- WotC / Vintage (examples) ----
    "bs":     {"set_name": "Base Set", "era": "Base/WotC", "border": "yellow", "language": "en"},
    "ju":     {"set_name": "Jungle", "era": "Base/WotC", "border": "yellow", "language": "en"},
    "fo":     {"set_name": "Fossil", "era": "Base/WotC", "border": "yellow", "language": "en"},
    # Add everything you want below… keep keys normalized (see _norm_code)
}

def _norm_code(code: str) -> str:
    if not code:
        return ""
    code = code.strip()
    # Replace punctuation with space, collapse multi-spaces, lower
    for ch in ".-_/\\|:;,":
        code = code.replace(ch, " ")
    code = " ".join(code.split()).lower()
    return code

def _resolve_set_info(code: str, lang_hint: str = "unknown") -> Dict[str, str]:
    """
    Try direct map lookup; fall back to prefix token matches.
    Returns a dict with defaults if not found.
    """
    nc = _norm_code(code)
    # direct
    if nc in SET_CODE_MAP:
        info = dict(SET_CODE_MAP[nc])
    else:
        # try first-token matching (e.g., "sv2a 201/165 sar" -> "sv2a")
        first = nc.split(" ")[0] if nc else ""
        info = dict(SET_CODE_MAP.get(first, {}))
        if not info:
            # try two-token
            toks = nc.split(" ")
            if len(toks) >= 2:
                two = " ".join(toks[:2])
                info = dict(SET_CODE_MAP.get(two, {}))
    # defaults
    info.setdefault("set_name", "")
    info.setdefault("era", "")
    info.setdefault("border", "")
    # prefer detected language if present
    info["language"] = info.get("language") or (lang_hint if lang_hint in {"en","jp"} else "unknown")
    info["set_code"] = code or ""
    return info

# ---------------------------
# Optional: Set-symbol → style map (EDIT/EXTEND THESE NAMES)
# Keys must match your PNG filenames (without extension) in SET_SYMBOLS_DIR.
# ---------------------------
SYMBOL_STYLE_MAP: Dict[str, Dict[str, str]] = {
    # WotC (Base era)
    "base_set": {"set_name": "Base Set", "era": "Base/WotC", "border": "yellow"},
    "jungle": {"set_name": "Jungle", "era": "Base/WotC", "border": "yellow"},
    "fossil": {"set_name": "Fossil", "era": "Base/WotC", "border": "yellow"},
    "team_rocket": {"set_name": "Team Rocket", "era": "Base/WotC", "border": "yellow"},
    "gym_challenge": {"set_name": "Gym Challenge", "era": "Base/WotC", "border": "yellow"},
    "gym_heroes": {"set_name": "Gym Heroes", "era": "Base/WotC", "border": "yellow"},
    "neo_genesis": {"set_name": "Neo Genesis", "era": "Base/WotC", "border": "yellow"},
    "neo_discovery": {"set_name": "Neo Discovery", "era": "Base/WotC", "border": "yellow"},
    "neo_revelation": {"set_name": "Neo Revelation", "era": "Base/WotC", "border": "yellow"},
    "neo_destiny": {"set_name": "Neo Destiny", "era": "Base/WotC", "border": "yellow"},
    "legendary_collection": {"set_name": "Legendary Collection", "era": "Base/WotC", "border": "yellow"},
    "southern_islands": {"set_name": "Southern Islands", "era": "Base/WotC", "border": "yellow"},

    # e-Card
    "expedition": {"set_name": "Expedition Base Set", "era": "e-Card", "border": "yellow"},
    "aquapolis": {"set_name": "Aquapolis", "era": "e-Card", "border": "yellow"},
    "skyridge": {"set_name": "Skyridge", "era": "e-Card", "border": "yellow"},

    # EX
    "ruby_and_sapphire": {"set_name": "EX Ruby & Sapphire", "era": "EX", "border": "yellow"},
    "sandstorm": {"set_name": "EX Sandstorm", "era": "EX", "border": "yellow"},
    "dragon": {"set_name": "EX Dragon", "era": "EX", "border": "yellow"},
    "team_magma_vs_team_aqua": {"set_name": "EX Team Magma vs Team Aqua", "era": "EX", "border": "yellow"},
    "hidden_legends": {"set_name": "EX Hidden Legends", "era": "EX", "border": "yellow"},
    "fire_red_and_leaf_green": {"set_name": "EX FireRed & LeafGreen", "era": "EX", "border": "yellow"},
    "team_rocket_returns": {"set_name": "EX Team Rocket Returns", "era": "EX", "border": "yellow"},
    "deoxys": {"set_name": "EX Deoxys", "era": "EX", "border": "yellow"},
    "emerald": {"set_name": "EX Emerald", "era": "EX", "border": "yellow"},
    "unseen_forces": {"set_name": "EX Unseen Forces", "era": "EX", "border": "yellow"},
    "delta_species": {"set_name": "EX Delta Species", "era": "EX", "border": "yellow"},
    "legend_maker": {"set_name": "EX Legend Maker", "era": "EX", "border": "yellow"},
    "holon_phantoms": {"set_name": "EX Holon Phantoms", "era": "EX", "border": "yellow"},
    "crystal_guardians": {"set_name": "EX Crystal Guardians", "era": "EX", "border": "yellow"},
    "dragon_frontiers": {"set_name": "EX Dragon Frontiers", "era": "EX", "border": "yellow"},
    "power_keepers": {"set_name": "EX Power Keepers", "era": "EX", "border": "yellow"},

    # Diamond & Pearl
    "diamond_and_pearl": {"set_name": "Diamond & Pearl", "era": "DP", "border": "yellow"},
    "mysterious_treasures": {"set_name": "Mysterious Treasures", "era": "DP", "border": "yellow"},
    "secret_wonders": {"set_name": "Secret Wonders", "era": "DP", "border": "yellow"},
    "great_encounters": {"set_name": "Great Encounters", "era": "DP", "border": "yellow"},
    "majestic_dawn": {"set_name": "Majestic Dawn", "era": "DP", "border": "yellow"},
    "legends_awakened": {"set_name": "Legends Awakened", "era": "DP", "border": "yellow"},
    "stormfront": {"set_name": "Stormfront", "era": "DP", "border": "yellow"},

    # Platinum
    "platinum_base_set": {"set_name": "Platinum", "era": "Platinum", "border": "yellow"},
    "rising_rivals": {"set_name": "Rising Rivals", "era": "Platinum", "border": "yellow"},
    "supreme_victors": {"set_name": "Supreme Victors", "era": "Platinum", "border": "yellow"},
    "arceus": {"set_name": "Arceus", "era": "Platinum", "border": "yellow"},

    # HeartGold & SoulSilver
    "heartgold_and_soulsilver": {"set_name": "HeartGold & SoulSilver", "era": "HGSS", "border": "yellow"},
    "unleashed": {"set_name": "HS—Unleashed", "era": "HGSS", "border": "yellow"},
    "undaunted": {"set_name": "HS—Undaunted", "era": "HGSS", "border": "yellow"},
    "triumphant": {"set_name": "HS—Triumphant", "era": "HGSS", "border": "yellow"},
    "call_of_legends": {"set_name": "Call of Legends", "era": "HGSS", "border": "yellow"},

    # Black & White
    "black_and_white_base_set": {"set_name": "Black & White", "era": "BW", "border": "yellow"},
    "emerging_powers": {"set_name": "Emerging Powers", "era": "BW", "border": "yellow"},
    "noble_victories": {"set_name": "Noble Victories", "era": "BW", "border": "yellow"},
    "next_destinies": {"set_name": "Next Destinies", "era": "BW", "border": "yellow"},
    "dark_explorers": {"set_name": "Dark Explorers", "era": "BW", "border": "yellow"},
    "dragons_exalted": {"set_name": "Dragons Exalted", "era": "BW", "border": "yellow"},
    "boundaries_crossed": {"set_name": "Boundaries Crossed", "era": "BW", "border": "yellow"},
    "plasma_storm": {"set_name": "Plasma Storm", "era": "BW", "border": "yellow"},
    "plasma_freeze": {"set_name": "Plasma Freeze", "era": "BW", "border": "yellow"},
    "plasma_blast": {"set_name": "Plasma Blast", "era": "BW", "border": "yellow"},
    "legendary_treasures": {"set_name": "Legendary Treasures", "era": "BW", "border": "yellow"},

    # XY
    "xy": {"set_name": "XY Base Set", "era": "XY", "border": "yellow"},
    "flashfire": {"set_name": "Flashfire", "era": "XY", "border": "yellow"},
    "furious_fists": {"set_name": "Furious Fists", "era": "XY", "border": "yellow"},
    "phantom_forces": {"set_name": "Phantom Forces", "era": "XY", "border": "yellow"},
    "primal_clash": {"set_name": "Primal Clash", "era": "XY", "border": "yellow"},
    "roaring_skies": {"set_name": "Roaring Skies", "era": "XY", "border": "yellow"},
    "ancient_origins": {"set_name": "Ancient Origins", "era": "XY", "border": "yellow"},
    "breakthrough": {"set_name": "BREAKthrough", "era": "XY", "border": "yellow"},
    "breakpoint": {"set_name": "BREAKpoint", "era": "XY", "border": "yellow"},
    "generations": {"set_name": "Generations", "era": "XY", "border": "yellow"},
    "fates_collide": {"set_name": "Fates Collide", "era": "XY", "border": "yellow"},
    "steam_siege": {"set_name": "Steam Siege", "era": "XY", "border": "yellow"},
    "evolutions": {"set_name": "Evolutions", "era": "XY", "border": "yellow"},

    # Sun & Moon
    "sun_and_moon": {"set_name": "Sun & Moon", "era": "SM", "border": "yellow"},
    "guardians_rising": {"set_name": "Guardians Rising", "era": "SM", "border": "yellow"},
    "burning_shadows": {"set_name": "Burning Shadows", "era": "SM", "border": "yellow"},
    "crimson_invasion": {"set_name": "Crimson Invasion", "era": "SM", "border": "yellow"},
    "ultra_prism": {"set_name": "Ultra Prism", "era": "SM", "border": "yellow"},
    "forbidden_light": {"set_name": "Forbidden Light", "era": "SM", "border": "yellow"},
    "celestial_storm": {"set_name": "Celestial Storm", "era": "SM", "border": "yellow"},
    "dragon_majesty": {"set_name": "Dragon Majesty", "era": "SM", "border": "yellow"},
    "lost_thunder": {"set_name": "Lost Thunder", "era": "SM", "border": "yellow"},
    "team_up": {"set_name": "Team Up", "era": "SM", "border": "yellow"},
    "unbroken_bonds": {"set_name": "Unbroken Bonds", "era": "SM", "border": "yellow"},
    "unified_minds": {"set_name": "Unified Minds", "era": "SM", "border": "yellow"},
    "hidden_fates": {"set_name": "Hidden Fates", "era": "SM", "border": "yellow"},
    "cosmic_eclipse": {"set_name": "Cosmic Eclipse", "era": "SM", "border": "yellow"},
    "detective_pikachu": {"set_name": "Detective Pikachu", "era": "SM", "border": "yellow"},

    # Sword & Shield
    "sword_and_shield": {"set_name": "Sword & Shield", "era": "SWSH", "border": "yellow"},
    "rebel_clash": {"set_name": "Rebel Clash", "era": "SWSH", "border": "yellow"},
    "darkness_ablaze": {"set_name": "Darkness Ablaze", "era": "SWSH", "border": "yellow"},
    "vivid_voltage": {"set_name": "Vivid Voltage", "era": "SWSH", "border": "yellow"},
    "battle_styles": {"set_name": "Battle Styles", "era": "SWSH", "border": "yellow"},
    "chilling_reign": {"set_name": "Chilling Reign", "era": "SWSH", "border": "yellow"},
    "evolving_skies": {"set_name": "Evolving Skies", "era": "SWSH", "border": "yellow"},
    "fusion_strike": {"set_name": "Fusion Strike", "era": "SWSH", "border": "yellow"},
    "brilliant_stars": {"set_name": "Brilliant Stars", "era": "SWSH", "border": "yellow"},
    "astral_radiance": {"set_name": "Astral Radiance", "era": "SWSH", "border": "yellow"},
    "lost_origin": {"set_name": "Lost Origin", "era": "SWSH", "border": "yellow"},
    "silver_tempest": {"set_name": "Silver Tempest", "era": "SWSH", "border": "yellow"},
    "shining_fates": {"set_name": "Shining Fates", "era": "SWSH", "border": "yellow"},
    "pokemon_go": {"set_name": "Pokémon GO", "era": "SWSH", "border": "yellow"},
    "celebrations": {"set_name": "Celebrations", "era": "SWSH", "border": "yellow"},
    "champions_path": {"set_name": "Champion’s Path", "era": "SWSH", "border": "yellow"},
    "crown_zenith": {"set_name": "Crown Zenith", "era": "SWSH", "border": "yellow"},

    # Scarlet & Violet (silver border)
    "scarlet_and_violet": {"set_name": "Scarlet & Violet", "era": "SV", "border": "silver"},
    "paldea_evolved": {"set_name": "Paldea Evolved", "era": "SV", "border": "silver"},
    "obsidian_flames": {"set_name": "Obsidian Flames", "era": "SV", "border": "silver"},
    "paradox_rift": {"set_name": "Paradox Rift", "era": "SV", "border": "silver"},
    "temporal_forces": {"set_name": "Temporal Forces", "era": "SV", "border": "silver"},
    "twilight_masquerade": {"set_name": "Twilight Masquerade", "era": "SV", "border": "silver"},
    "stellar_crown": {"set_name": "Stellar Crown", "era": "SV", "border": "silver"},
    "prismatic_evolutions": {"set_name": "Prismatic Evolutions", "era": "SV", "border": "silver"},
    "scarlet_and_violet_151": {"set_name": "Scarlet & Violet 151", "era": "SV", "border": "silver"},

    # Specials / mini / POP / promos / kits
    "promos": {"set_name": "Black Star Promos", "era": "Promo", "border": "yellow"},
    "pop_series_1": {"set_name": "POP Series 1", "era": "Promo", "border": "yellow"},
    "pop_series_2": {"set_name": "POP Series 2", "era": "Promo", "border": "yellow"},
    "pop_series_3": {"set_name": "POP Series 3", "era": "Promo", "border": "yellow"},
    "pop_series_4": {"set_name": "POP Series 4", "era": "Promo", "border": "yellow"},
    "pop_series_5": {"set_name": "POP Series 5", "era": "Promo", "border": "yellow"},
    "pop_series_6": {"set_name": "POP Series 6", "era": "Promo", "border": "yellow"},
    "pop_series_7": {"set_name": "POP Series 7", "era": "Promo", "border": "yellow"},
    "pop_series_8": {"set_name": "POP Series 8", "era": "Promo", "border": "yellow"},
    "pop_series_9": {"set_name": "POP Series 9", "era": "Promo", "border": "yellow"},

    "gym_challenge": {"set_name": "Gym Challenge", "era": "Base/WotC", "border": "yellow"},  # already above via BW gym_challenge icon too

    # Trainer Kits (treat as Promo-ish)
    "trainer_kit_excadri ll".replace(" ", ""): {"set_name": "Trainer Kit: Excadrill", "era": "BW", "border": "yellow"},
    "trainer_kit_gyarados": {"set_name": "Trainer Kit: Gyarados", "era": "XY", "border": "yellow"},
    "trainer_kit_latias": {"set_name": "Trainer Kit: Latias", "era": "EX", "border": "yellow"},
    "trainer_kit_latios": {"set_name": "Trainer Kit: Latios", "era": "EX", "border": "yellow"},
    "trainer_kit_lycanroc": {"set_name": "Trainer Kit: Lycanroc", "era": "SM", "border": "yellow"},
    "trainer_kit_manaphy_lucario": {"set_name": "Trainer Kit: Manaphy & Lucario", "era": "XY", "border": "yellow"},
    "trainer_kit_noivern": {"set_name": "Trainer Kit: Noivern", "era": "XY", "border": "yellow"},
    "trainer_kit_pikachu_libre": {"set_name": "Trainer Kit: Pikachu Libre", "era": "XY", "border": "yellow"},
    "trainer_kit_raichu": {"set_name": "Trainer Kit: Raichu", "era": "EX", "border": "yellow"},
    "trainer_kit_alolan_raichu": {"set_name": "Trainer Kit: Alolan Raichu", "era": "SM", "border": "yellow"},
    "trainer_kit_suicune": {"set_name": "Trainer Kit: Suicune", "era": "EX", "border": "yellow"},
    "trainer_kit_sylveon": {"set_name": "Trainer Kit: Sylveon", "era": "XY", "border": "yellow"},
    "trainer_kit_wigglytuff": {"set_name": "Trainer Kit: Wigglytuff", "era": "EX", "border": "yellow"},
    "trainer_kit_zoroark": {"set_name": "Trainer Kit: Zoroark", "era": "BW", "border": "yellow"},

    # Misc seen in screenshots
    "call_of_legends": {"set_name": "Call of Legends", "era": "HGSS", "border": "yellow"},
    "celebrations_classic_collection": {"set_name": "Celebrations: Classic Collection", "era": "SWSH", "border": "yellow"},
    "double_crisis": {"set_name": "Double Crisis", "era": "XY", "border": "yellow"},
    "dragon_vault": {"set_name": "Dragon Vault", "era": "BW", "border": "yellow"},
    "evolving_skies": {"set_name": "Evolving Skies", "era": "SWSH", "border": "yellow"},
    "guardians_rising": {"set_name": "Guardians Rising", "era": "SM", "border": "yellow"},
    "hidden_fates": {"set_name": "Hidden Fates", "era": "SM", "border": "yellow"},
    "platinum_storm".replace("_", "plasma_storm"): {"set_name": "Plasma Storm", "era": "BW", "border": "yellow"},  # safety

    # Old mini-lines
    "power_keepers": {"set_name": "Power Keepers", "era": "EX", "border": "yellow"},
}


# ---------------------------
# Helpers
# ---------------------------
def _file_to_data_url(path: Path) -> str:
    mime, _ = mimetypes.guess_type(str(path))
    if not mime:
        mime = "image/jpeg"
    b64 = base64.b64encode(Path(path).read_bytes()).decode("utf-8")
    return f"data:{mime};base64,{b64}"

def _bgr_to_data_url(img_bgr: np.ndarray, mime="image/jpeg", quality=92) -> str:
    img_rgb = cv2.cvtColor(img_bgr, cv2.COLOR_BGR2RGB)
    pil = Image.fromarray(img_rgb)
    buf = io.BytesIO()
    pil.save(buf, format="JPEG", quality=quality)
    b64 = base64.b64encode(buf.getvalue()).decode("utf-8")
    return f"data:{mime};base64,{b64}"

def _img_part(path: Path) -> Dict[str, Any]:
    return {"type": "image_url", "image_url": {"url": _file_to_data_url(path)}}

def _img_part_from_data_url(data_url: str) -> Dict[str, Any]:
    return {"type": "image_url", "image_url": {"url": data_url}}

def _safe_float(x, d=0.0):
    try:
        return float(x)
    except Exception:
        return d

def _preprocess_card_to_np(path: Path):
    """Return warped BGR np.ndarray or None."""
    img_bgr = cv2.imread(str(path))
    if img_bgr is None:
        return None
    return _warp_card(img_bgr)

def _apply_sanity_caps(result: Dict[str, Any]) -> Dict[str, Any]:
    """
    If LLM summary/observations imply heavy flaws, cap overall grade accordingly.
    """
    text = (result.get("summary", "") + " " +
            " ".join(o.get("note","") for o in (result.get("observations") or []))).lower()

    def cap(grade_cap: float, qualifier: Optional[str] = None):
        if result["predicted_grade"] > grade_cap:
            result["predicted_grade"] = float(grade_cap)
        if qualifier and qualifier not in (result.get("predicted_label") or ""):
            lbl = result.get("predicted_label") or ""
            result["predicted_label"] = (lbl + f" [{qualifier}]").strip()

    # Writing/ink/marker/scribble ⇒ MK qualifier + cap to 3
    if any(k in text for k in ["ink", "writing", "written", "marker", "scribble", "scribbles", "pen", "crayon"]):
        cap(3.0, "MK (marked)")
        result["scores"]["surface"] = min(result["scores"]["surface"], 3.0)

    # Crease/bend/tear/paper loss ⇒ cap at 4
    if any(k in text for k in ["crease", "bent", "bend", "fold", "tear", "rip", "paper loss", "missing paper"]):
        cap(4.0, None)

    # Any “heavy/obvious/large/significant” ⇒ cap ≤7.5
    if any(k in text for k in ["heavy", "obvious", "large", "significant"]):
        cap(7.5, None)

    # Grades 9–10 require no visible wear
    if result["predicted_grade"] >= 9.0:
        visible = any(k in text for k in [
            "whitening", "chip", "scratch", "dent", "dimple", "stain", "ink", "marker", "corner wear", "edge wear"
        ])
        if visible:
            cap(8.0, None)

    return result

# --- PSA text buckets (server-side, deterministic) --------------------------
def _psa_bucket_text(grade: float) -> str:
    g = int(round(max(1.0, min(10.0, float(grade or 0)))))
    short = {
        10: "GEM MT", 9: "MINT", 8: "NM-MT", 7: "NM",
        6: "EX-MT", 5: "EX", 4: "VG-EX", 3: "VG", 2: "GOOD", 1: "POOR"
    }[g]
    long = {
        10: "Gem Mint", 9: "Mint", 8: "Near Mint-Mint", 7: "Near Mint",
        6: "Excellent-Mint", 5: "Excellent", 4: "Very Good-Excellent",
        3: "Very Good", 2: "Good", 1: "Poor"
    }[g]
    return f"{short} ({long})"

def _compose_summary_from_scores(scores: dict, flags: Optional[dict] = None, detected: Optional[dict] = None) -> str:
    flags = flags or {}
    cent   = float(scores.get("centering", 10))
    surf   = float(scores.get("surface",   10))
    edges  = float(scores.get("edges",     10))
    corners= float(scores.get("corners",   10))
    color  = float(scores.get("color",     10))

    notes = []

    # Centering
    if cent < 5.5:
        notes.append("noticeable off-centering")
    elif cent < 7.5:
        notes.append("slight off-centering")

    # Surface
    if flags.get("scribble") or surf < 3.5:
        notes.append("heavy surface damage")
    elif surf < 5.5:
        notes.append("moderate surface wear")
    elif surf < 7.5:
        notes.append("light surface wear")

    # Edges / corners
    if edges < 5.5:
        notes.append("edge wear")
    elif edges < 7.5:
        notes.append("slight edge wear")

    if corners < 5.5:
        notes.append("corner wear")
    elif corners < 7.5:
        notes.append("slight corner wear")

    # Color
    if color < 6.5:
        notes.append("color fading/discoloration")

    # Base sentence
    if not notes:
        text = "The card presents very well with minimal visible wear."
    else:
        text = "The card shows " + (notes[0] if len(notes) == 1 else (", ".join(notes[:-1]) + f", and {notes[-1]}."))

    # Photo warnings
    photo_notes = []
    if flags.get("glare"): photo_notes.append("glare")
    if flags.get("blur"):  photo_notes.append("blur")
    if photo_notes:
        text += f" Photo quality issue detected ({', '.join(photo_notes)}); result may be conservative."

    # Append detected metadata line
    if isinstance(detected, dict) and detected:
        cname = (detected.get("card_name") or "").strip()
        sname = (detected.get("set_name") or "").strip()
        scode = (detected.get("set_code") or "").strip()
        extra = []
        if cname: extra.append(cname)
        if sname: extra.append(sname)
        if scode: extra.append(scode)
        if extra:
            text += " Detected: " + " — ".join(extra) + "."

    return text

def _coerce_label_and_summary(result: dict, flags: Optional[dict] = None, detected: Optional[dict] = None) -> dict:
    grade = float(result.get("predicted_grade", 0))
    result["predicted_label"] = _psa_bucket_text(grade)
    result["summary"] = _compose_summary_from_scores(result.get("scores", {}), flags, detected)
    return result

# ---------------------------
# Stage 1: gating / classification
# ---------------------------
CLASSIFY_PROMPT = (
    "You are a strict intake checker for TCG card photos.\n"
    "You will receive two images. For each image, decide if it shows a card FRONT or card BACK.\n"
    "Rules of thumb for Pokémon: backs are the blue design with the Poké Ball and 'Pokémon' logo; "
    "fronts show the card artwork, text boxes, set symbol/number, etc.\n"
    "Rules of thumb for One Piece: backs have a compass emblem and 'ONE PIECE CARD GAME' text, usually on a blue (sometimes white/red) field.\n"
    "Rules of thumb for Magic: The Gathering: backs are brown/sepia with five mana orbs and 'Magic: The Gathering'.\n"
    "Also rate overall photo quality as 'low'|'medium'|'high'.\n"
    "Return STRICT JSON ONLY:\n"
    "{\n"
    '  "detected_sides": {"image_1":"front|back|unknown", "image_2":"front|back|unknown"},\n'
    '  "image_quality": "low|medium|high"\n'
    "}\n"
)

def _classify_images(img1: Path, img2: Optional[Path]) -> Dict[str, Any]:
    content = [{"type": "text", "text": "Classify these two images (order matters)."}]
    content.append(_img_part(img1))
    if img2:
        content.append(_img_part(img2))
    else:
        content.append({"type": "text", "text": "Second image is missing."})

    resp = client.chat.completions.create(
        model=OPENAI_MODEL_CLASS,
        temperature=0.0,
        messages=[
            {"role": "system", "content": CLASSIFY_PROMPT},
            {"role": "user", "content": content},
        ],
    )
    raw = (resp.choices[0].message.content or "{}").strip()
    try:
        data = json.loads(raw)
    except Exception:
        s, e = raw.find("{"), raw.rfind("}")
        data = json.loads(raw[s:e+1]) if s != -1 and e != -1 and e > s else {}

    ds = data.get("detected_sides") or {}
    data["detected_sides"] = {
        "image_1": str(ds.get("image_1", "unknown")),
        "image_2": str(ds.get("image_2", "unknown")),
    }
    data["image_quality"] = (data.get("image_quality") or "low").lower()
    return data

# ---------------------------
# Stage 2: grading prompts
# ---------------------------
GRADE_PROMPT_GENERIC = (
    "You are a meticulous pre-grader for TCG cards using a PSA-like 1..10 scale (10=Gem Mint).\n"
    "You will receive FRONT then BACK images of the same card. Do not deduct unless you can name at least one "
    "concrete, visible observation.\n"
    "\n"
    "SEVERITY & HARD CAPS (must obey):\n"
    "• Any writing/ink/marker/scribble/crayon or foreign substance on the card surface ⇒ cap overall grade at 3 (Good) "
    "  and include the qualifier 'MK (marked)' in the predicted_label.\n"
    "• Any crease/bend/tear/paper loss ⇒ cap overall grade at 4 (VG-EX) or lower depending on severity.\n"
    "• Obvious edge whitening or chipped corners on multiple edges ⇒ typical cap around 6–7.\n"
    "• Grades 9–10 require NO obvious defects: only microscopic corner touches or trivial print lines are allowed; "
    "  if you see any visible wear, do not exceed 8.\n"
    "\n"
    "PROCESS (mandatory):\n"
    "• Split each image into a 5×5 grid; scan top→bottom, left→right.\n"
    "• Centering: estimate border thickness on all four sides—front weighted more, back too; report off-center directions.\n"
    "• Surface: look for print lines, scratches, stains, dents/dimples, ink/writing/marks, creases; distinguish true defects from glare.\n"
    "• Edges: zoom along all edges for whitening/chips; avoid confusing holo sparkles with wear.\n"
    "• Corners: zoom on all four corners for rounding, fray, whitening.\n"
    "• Color: check fading/yellowing/oversaturation/uneven tones.\n"
    "• If anything prevents accurate grading (blurry, glare, crop, two fronts/two backs), set needs_better_photos=true and "
    "  return zeroes for scores with clear photo_feedback.\n"
    "\n"
    "OUTPUT STRICT JSON ONLY:\n"
    "{\n"
    '  "scores": {"centering": number, "surface": number, "edges": number, "corners": number, "color": number},\n'
    '  "predicted_grade": number,\n'
    '  "predicted_label": string,\n'
    '  "needs_better_photos": boolean,\n'
    '  "photo_feedback": string,\n'
    '  "observations": [\n'
    '    {"category":"centering|surface|edges|corners|color","side":"front|back","note":"short detail","box":[x0,y0,x1,y1]}\n'
    "  ],\n"
    '  "summary": string\n'
    "}\n"
)

def _build_game_prompt(game: Optional[str]) -> str:
    g = (game or "").lower()
    if g not in GAME_LABELS:
        return GRADE_PROMPT_GENERIC
    return (
        f"You are a meticulous pre-grader for {GAME_LABELS[g]} TCG cards (PSA-like 1..10; 10=Gem Mint).\n"
        f"{GAME_BACK_RULES.get(g, '')}\n"
        "You will receive FRONT then BACK images of the same card. Do not deduct unless you can name at least one concrete, "
        "visible observation.\n"
        "SEVERITY & HARD CAPS (must obey):\n"
        "• Any writing/ink/marker/scribble/crayon or foreign substance on the card surface ⇒ cap overall grade at 3 (Good) "
        "  and include the qualifier 'MK (marked)' in the predicted_label.\n"
        "• Any crease/bend/tear/paper loss ⇒ cap overall grade at 4 (VG-EX) or lower depending on severity.\n"
        "• Obvious edge whitening or chipped corners on multiple edges ⇒ typical cap around 6–7.\n"
        "• Grades 9–10 require NO obvious defects: only microscopic corner touches or trivial print lines are allowed; "
        "  if you see any visible wear, do not exceed 8.\n"
        "\n"
        "PROCESS (mandatory):\n"
        "• Split each image into a 5×5 grid; scan top→bottom, left→right.\n"
        "• Centering: estimate border thickness on all four sides—front weighted more, back too; report off-center directions.\n"
        "• Surface: look for print lines, scratches, stains, dents/dimples, ink/writing/marks, creases; distinguish true defects from glare.\n"
        "• Edges: zoom along all edges for whitening/chips; avoid confusing holo sparkles with wear.\n"
        "• Corners: zoom on all four corners for rounding, fray, whitening.\n"
        "• Color: check fading/yellowing/oversaturation/uneven tones.\n"
        "• If anything prevents accurate grading (blurry, glare, crop, two fronts/two backs), set needs_better_photos=true and "
        "  return zeroes for scores with clear photo_feedback.\n"
        "\n"
        "OUTPUT STRICT JSON ONLY:\n"
        "{\n"
        '  "scores": {"centering": number, "surface": number, "edges": number, "corners": number, "color": number},\n'
        '  "predicted_grade": number,\n'
        '  "predicted_label": string,\n'
        '  "needs_better_photos": boolean,\n'
        '  "photo_feedback": string,\n'
        '  "observations": [\n'
        '    {"category":"centering|surface|edges|corners|color","side":"front|back","note":"short detail","box":[x0,y0,x1,y1]}\n'
        "  ],\n"
        '  "summary": string\n'
        "}\n"
    )

def _normalize_grade_json(data: Dict[str, Any]) -> Dict[str, Any]:
    s = data.get("scores", {}) or {}
    return {
        "scores": {
            "centering": _safe_float(s.get("centering"), 0.0),
            "surface":   _safe_float(s.get("surface"), 0.0),
            "edges":     _safe_float(s.get("edges"), 0.0),
            "corners":   _safe_float(s.get("corners"), 0.0),
            "color":     _safe_float(s.get("color"), 0.0),
        },
        "predicted_grade": _safe_float(data.get("predicted_grade"), 0.0),
        "predicted_label": str(data.get("predicted_label") or "").strip(),
        "needs_better_photos": bool(data.get("needs_better_photos", False)),
        "photo_feedback": str(data.get("photo_feedback") or "").strip(),
        "observations": data.get("observations") or [],
        "summary": str(data.get("summary") or "").strip(),
    }

def _enforce_observation_guard(result: Dict[str, Any]) -> Dict[str, Any]:
    if result.get("needs_better_photos"):
        return result
    obs = result.get("observations") or []
    has_concrete = any(isinstance(o, dict) and "category" in o for o in obs)
    if not has_concrete:
        result["scores"] = {k: 10.0 for k in ["centering","surface","edges","corners","color"]}
        result["predicted_grade"] = 10.0
        if not result.get("predicted_label"):
            result["predicted_label"] = "PSA 10 (Gem Mint)"
    return result

def _apply_observation_thresholds(result: Dict[str, Any]) -> Dict[str, Any]:
    """
    Require stronger evidence to drop below 9.5:
    - At least 2 concrete observations, or
    - One high-impact note (crease/dent/deep scratch).
    """
    obs = [o for o in (result.get("observations") or []) if isinstance(o, dict)]
    high_impact = {"crease", "dent", "deep scratch"}
    notes = " ".join((o.get("note","") or "").lower() for o in obs)
    has_high = any(word in notes for word in high_impact)
    if len(obs) < 2 and not has_high:
        for k in ["surface","edges","corners","color"]:
            result["scores"][k] = max(result["scores"][k], 9.5)
        result["predicted_grade"] = max(result["predicted_grade"], 9.5)
    return result

# ---------------------------
# Preprocess: crop/deskew card
# ---------------------------
def _to_data_url_from_pil(img: Image.Image, mime="image/jpeg") -> str:
    buf = io.BytesIO()
    img.save(buf, format="JPEG", quality=92)
    b64 = base64.b64encode(buf.getvalue()).decode("utf-8")
    return f"data:{mime};base64,{b64}"

def _order_points(pts):
    rect = np.zeros((4, 2), dtype="float32")
    s = pts.sum(axis=1)
    rect[0] = pts[np.argmin(s)]            # top-left
    rect[2] = pts[np.argmax(s)]            # bottom-right
    diff = np.diff(pts, axis=1)
    rect[1] = pts[np.argmin(diff)]         # top-right
    rect[3] = pts[np.argmax(diff)]         # bottom-left
    return rect

def _warp_card(img_bgr, target_h=896, target_w=640):
    gray = cv2.cvtColor(img_bgr, cv2.COLOR_BGR2GRAY)
    gray = cv2.GaussianBlur(gray, (5,5), 0)
    edges = cv2.Canny(gray, 40, 120)
    cnts, _ = cv2.findContours(edges, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    if not cnts:
        return None
    cnt = max(cnts, key=cv2.contourArea)
    peri = cv2.arcLength(cnt, True)
    approx = cv2.approxPolyDP(cnt, 0.02 * peri, True)
    if len(approx) != 4:
        return None
    pts = approx.reshape(4,2).astype("float32")
    rect = _order_points(pts)
    (tl, tr, br, bl) = rect
    wA = np.linalg.norm(br - bl)
    wB = np.linalg.norm(tr - tl)
    hA = np.linalg.norm(tr - br)
    hB = np.linalg.norm(tl - bl)
    maxW = int(max(wA, wB))
    maxH = int(max(hA, hB))
    dst = np.array([[0,0],[maxW-1,0],[maxW-1,maxH-1],[0,-1+maxH]], dtype="float32")
    M = cv2.getPerspectiveTransform(rect, dst)
    warp = cv2.warpPerspective(img_bgr, M, (maxW, maxH))
    warp = cv2.resize(warp, (target_w, target_h), interpolation=cv2.INTER_CUBIC)
    return warp

def _preprocess_card_to_data_url(path: Path) -> str:
    img_bgr = cv2.imread(str(path))
    if img_bgr is None:
        return _file_to_data_url(path)
    warped = _warp_card(img_bgr)
    if warped is None:
        return _file_to_data_url(path)
    # simple upside-down heuristic (optional)
    top = warped[:80,:,:].mean(); bot = warped[-80:,:,:].mean()
    if bot + 10 < top:
        warped = cv2.rotate(warped, cv2.ROTATE_180)
    pil = Image.fromarray(cv2.cvtColor(warped, cv2.COLOR_BGR2RGB))
    return _to_data_url_from_pil(pil)

# ---------------------------
# OCR-lite for set code (bottom strip) & card name (top bar)
# ---------------------------
SET_CODE_PROMPT = (
    "You will see a cropped bottom border of a TCG card. "
    "Extract the SHORT printed set code near the set symbol/collector number. "
    "Examples: 'sv2a', 'TEF EN', 'PRE EN', 'SVI EN'. "
    "Return STRICT JSON ONLY with fields:\n"
    '{ "set_code": "string_or_empty", "language": "en|jp|unknown" }\n'
    "Rules:\n"
    "• Only letters/numbers/spaces in set_code (no punctuation), keep case as printed if Latin else lowercase.\n"
    "• If multiple strings present, choose the one that best matches a short set identifier (1–8 chars).\n"
    "• If unsure, set set_code=\"\" and language=\"unknown\"."
)

CARD_NAME_PROMPT = (
    "You will see a cropped top title bar of a TCG card. "
    "Extract the CARD NAME text only. Return STRICT JSON ONLY:\n"
    '{ "card_name": "string_or_empty" }'
)

def _crop_bottom_strip(img_bgr: Optional[np.ndarray], frac: float = 0.18) -> Optional[np.ndarray]:
    if img_bgr is None:
        return None
    h, w = img_bgr.shape[:2]
    strip_h = max(8, int(h * frac))
    y0 = max(0, h - strip_h)
    return img_bgr[y0:h, 0:w].copy()

def _crop_top_strip(img_bgr: Optional[np.ndarray], frac: float = 0.16) -> Optional[np.ndarray]:
    if img_bgr is None:
        return None
    h, w = img_bgr.shape[:2]
    strip_h = max(8, int(h * frac))
    return img_bgr[0:strip_h, 0:w].copy()

def _extract_set_code_via_llm(img_bgr: Optional[np.ndarray]) -> Dict[str, str]:
    if img_bgr is None:
        return {"set_code": "", "language": "unknown"}
    strip = _crop_bottom_strip(img_bgr, 0.18)
    if strip is None:
        return {"set_code": "", "language": "unknown"}
    strip_url = _bgr_to_data_url(strip, quality=95)

    resp = client.chat.completions.create(
        model=OPENAI_MODEL_CLASS,
        temperature=0.0,
        messages=[
            {"role": "system", "content": SET_CODE_PROMPT},
            {"role": "user", "content": [
                {"type": "text", "text": "Read the set code from this bottom strip."},
                {"type": "image_url", "image_url": {"url": strip_url}}
            ]},
        ],
    )
    raw = (resp.choices[0].message.content or "").strip()
    s, e = raw.find("{"), raw.rfind("}")
    if s != -1 and e != -1 and e > s:
        raw = raw[s:e+1]
    try:
        data = json.loads(raw)
    except Exception:
        data = {}
    code = str(data.get("set_code") or "").strip()
    lang = str(data.get("language") or "unknown").strip().lower()
    code = code.replace(".", " ").replace("-", " ").strip()
    code = " ".join(code.split())
    return {"set_code": code, "language": lang if lang in {"en","jp"} else "unknown"}

def _extract_card_name_via_llm(img_bgr: Optional[np.ndarray]) -> str:
    if img_bgr is None:
        return ""
    strip = _crop_top_strip(img_bgr, 0.16)
    if strip is None:
        return ""
    strip_url = _bgr_to_data_url(strip, quality=95)

    resp = client.chat.completions.create(
        model=OPENAI_MODEL_CLASS,
        temperature=0.0,
        messages=[
            {"role": "system", "content": CARD_NAME_PROMPT},
            {"role": "user", "content": [
                {"type": "text", "text": "Read the card name from this top bar."},
                {"type": "image_url", "image_url": {"url": strip_url}}
            ]},
        ],
    )
    raw = (resp.choices[0].message.content or "").strip()
    s, e = raw.find("{"), raw.rfind("}")
    if s != -1 and e != -1 and e > s:
        raw = raw[s:e+1]
    try:
        data = json.loads(raw)
    except Exception:
        data = {}
    return str(data.get("card_name") or "").strip()

# ---------------------------
# Set symbol detection (template matching on your PNG assets)
# ---------------------------
def _iter_symbol_pngs(folder: str) -> List[Path]:
    try:
        p = Path(folder)
        if not p.exists():
            return []
        return sorted([f for f in p.iterdir() if f.suffix.lower() in {".png", ".webp"}])
    except Exception:
        return []

def _load_symbol_template(png_path: Path) -> Tuple[np.ndarray, Optional[np.ndarray]]:
    """
    Returns (tpl_gray, mask or None). Handles transparent PNGs.
    """
    img = cv2.imread(str(png_path), cv2.IMREAD_UNCHANGED)
    if img is None:
        return None, None
    if img.ndim == 3:
        # no alpha
        tpl_bgr = img
        tpl_gray = cv2.cvtColor(tpl_bgr, cv2.COLOR_BGR2GRAY)
        mask = None
    else:
        # BGRA
        bgr = img[:, :, :3]
        alpha = img[:, :, 3]
        tpl_gray = cv2.cvtColor(bgr, cv2.COLOR_BGR2GRAY)
        # Build mask where alpha>0
        mask = cv2.threshold(alpha, 1, 255, cv2.THRESH_BINARY)[1]
    return tpl_gray, mask

_SYMBOL_CACHE: Dict[str, List[Tuple[str, np.ndarray, Optional[np.ndarray]]]] = {}

def _get_symbol_templates() -> List[Tuple[str, np.ndarray, Optional[np.ndarray]]]:
    """
    Lazy load and cache all symbol templates from SET_SYMBOLS_DIR.
    Returns list of (symbol_id, tpl_gray, mask).
    symbol_id is filename stem (lowercased).
    """
    global _SYMBOL_CACHE
    key = str(Path(SET_SYMBOLS_DIR).resolve())
    if key in _SYMBOL_CACHE:
        return _SYMBOL_CACHE[key]
    templates: List[Tuple[str, np.ndarray, Optional[np.ndarray]]] = []
    for f in _iter_symbol_pngs(SET_SYMBOLS_DIR):
        stem = f.stem.lower()
        tpl_gray, mask = _load_symbol_template(f)
        if tpl_gray is None:
            continue
        # Normalize template height for more stable matching
        h, w = tpl_gray.shape[:2]
        if h <= 0 or w <= 0:
            continue
        scale = SYMBOL_TARGET_H / float(h)
        if scale > 0 and abs(scale - 1.0) > 0.01:
            new_w = max(1, int(round(w * scale)))
            new_h = max(1, int(round(h * scale)))
            tpl_gray = cv2.resize(tpl_gray, (new_w, new_h), interpolation=cv2.INTER_AREA)
            if mask is not None:
                mask = cv2.resize(mask, (new_w, new_h), interpolation=cv2.INTER_NEAREST)
        templates.append((stem, tpl_gray, mask))
    _SYMBOL_CACHE[key] = templates
    return templates

def _bottom_symbol_roi(img_bgr: np.ndarray) -> np.ndarray:
    """
    Heuristic ROI where set symbols usually live (bottom band, center-ish).
    Safe default if layouts vary.
    """
    h, w = img_bgr.shape[:2]
    y0 = int(h * 0.62)
    y1 = h
    x0 = int(w * 0.10)
    x1 = int(w * 0.90)
    return img_bgr[y0:y1, x0:x1].copy()

def _detect_set_symbol(img_bgr: Optional[np.ndarray]) -> Tuple[str, float]:
    """
    Returns (best_symbol_id_or_empty, confidence 0..1)
    Uses TM_CCORR_NORMED, supports mask if available (OpenCV>=4.2).
    Gracefully degrades if no symbols folder or OpenCV lacks mask support.
    """
    if img_bgr is None:
        return "", 0.0

    templates = _get_symbol_templates()
    if not templates:
        return "", 0.0

    roi = _bottom_symbol_roi(img_bgr)
    if roi.size == 0:
        return "", 0.0
    roi_gray = cv2.cvtColor(roi, cv2.COLOR_BGR2GRAY)

    best_id, best_score = "", 0.0
    for sid, tpl_gray, mask in templates:
        try:
            method = cv2.TM_CCORR_NORMED
            if mask is not None:
                res = cv2.matchTemplate(roi_gray, tpl_gray, method, mask=mask)
            else:
                res = cv2.matchTemplate(roi_gray, tpl_gray, method)
            _, max_val, _, _ = cv2.minMaxLoc(res)
        except Exception:
            # fallback without mask if OpenCV build doesn't support it
            try:
                res = cv2.matchTemplate(roi_gray, tpl_gray, cv2.TM_CCOEFF_NORMED)
                _, max_val, _, _ = cv2.minMaxLoc(res)
            except Exception:
                max_val = 0.0
        if max_val > best_score:
            best_score = float(max_val)
            best_id = sid

    if best_score < SYMBOL_MIN_CONF:
        return "", best_score
    return best_id, best_score

def _style_from_symbol(symbol_id: str) -> Dict[str, str]:
    """
    Map symbol_id -> style dict using SYMBOL_STYLE_MAP. Safe defaults.
    """
    if not symbol_id:
        return {}
    style = dict(SYMBOL_STYLE_MAP.get(symbol_id, {}))
    style.setdefault("set_name", "")
    style.setdefault("era", "")
    style.setdefault("border", "")
    style["symbol_id"] = symbol_id
    return style

def _merge_style(code_info: Dict[str, str], symbol_style: Dict[str, str]) -> Dict[str, str]:
    """
    Merge code-derived info with symbol-derived style.
    Preference:
      - If code_info has set_name/era/border, keep them (codes are very precise for modern SV).
      - Otherwise, fill from symbol_style.
    """
    merged = dict(code_info or {})
    for k in ("set_name", "era", "border"):
        if not (merged.get(k) or "").strip():
            v = (symbol_style.get(k) or "").strip()
            if v:
                merged[k] = v
    if "symbol_id" in symbol_style:
        merged["set_symbol"] = symbol_style["symbol_id"]
    return merged

# ---------------------------
# Main entry
# ---------------------------
def grade_with_openai(front_path: Path,
                      back_path: Optional[Path] = None,
                      game_hint: Optional[str] = None) -> Dict[str, Any]:
    """Gate + crop + LLM grade (+ optional CV blend)."""

    # 1) Gate: sides & quality
    gate = _classify_images(front_path, back_path)
    sides = gate.get("detected_sides", {})
    q = (gate.get("image_quality") or "low").lower()

    # Enforce order
    if REQUIRE_FRONT_FIRST:
        if sides.get("image_1") != "front" or sides.get("image_2") != "back":
            return {
                "scores": {"centering": 0.0, "surface": 0.0, "edges": 0.0, "corners": 0.0, "color": 0.0},
                "predicted_grade": 0.0,
                "predicted_label": "—",
                "needs_better_photos": True,
                "photo_feedback": "Upload the FRONT image first and the BACK image second.",
                "summary": "",
            }
    else:
        pair = {sides.get("image_1"), sides.get("image_2")}
        if not ("front" in pair and "back" in pair):
            return {
                "scores": {"centering": 0.0, "surface": 0.0, "edges": 0.0, "corners": 0.0, "color": 0.0},
                "predicted_grade": 0.0,
                "predicted_label": "—",
                "needs_better_photos": True,
                "photo_feedback": "Please upload exactly one FRONT and one BACK image.",
                "summary": "",
            }
        if sides.get("image_1") == "back" and sides.get("image_2") == "front":
            front_path, back_path = back_path, front_path

    if q not in {"medium", "high"}:
        return {
            "scores": {"centering": 0.0, "surface": 0.0, "edges": 0.0, "corners": 0.0, "color": 0.0},
            "predicted_grade": 0.0,
            "predicted_label": "—",
            "needs_better_photos": True,
            "photo_feedback": "Photo quality is too low (blur, glare or cropping).",
            "summary": "",
        }

    # 2) Preprocess → data URLs and warped np
    f_url = _preprocess_card_to_data_url(front_path)
    b_url = _preprocess_card_to_data_url(back_path) if back_path else None
    front_warp_bgr = _preprocess_card_to_np(front_path)

    # 2b) Read set code & card name
    set_code_info = _extract_set_code_via_llm(front_warp_bgr)
    set_code_txt = set_code_info.get("set_code", "")
    set_lang_txt = set_code_info.get("language", "unknown")
    card_name = _extract_card_name_via_llm(front_warp_bgr)

    # 2c) Detect set symbol from PNG assets
    try:
        symbol_id, symbol_conf = _detect_set_symbol(front_warp_bgr)
    except Exception:
        symbol_id, symbol_conf = "", 0.0

    # Resolve style info from code map + symbol map
    set_info = _resolve_set_info(set_code_txt, set_lang_txt)
    sym_style = _style_from_symbol(symbol_id)
    set_info = _merge_style(set_info, sym_style)
    set_info["card_name"] = card_name
    set_info["symbol_conf"] = float(symbol_conf)

    # 3) Choose prompt
    system_prompt = _build_game_prompt((game_hint or "").lower())
    game_label = GAME_LABELS.get((game_hint or "").lower(), "TCG")

    # 4) LLM grade (pass the set code + resolved set hint up-front)
    hint = ""
    if set_code_txt or set_info.get("set_name"):
        human = (set_info.get("set_name") or "").strip()
        era = (set_info.get("era") or "").strip()
        border = (set_info.get("border") or "").strip()
        nm = (card_name or "").strip()
        parts = []
        if set_code_txt: parts.append(f'Set code (OCR): "{set_code_txt}"')
        if human: parts.append(f"set: {human}")
        if era:   parts.append(f"era: {era}")
        if border:parts.append(f"border: {border}")
        if nm:    parts.append(f'card: "{nm}"')
        if symbol_id:
            parts.append(f"symbol: {symbol_id} ({set_info.get('symbol_conf', 0.0):.2f})")
        hint = " | " + " | ".join(parts)
    content = [{"type": "text", "text": f"FRONT then BACK of the same {game_label} card — grade per instructions.{hint}"}]
    content.append(_img_part_from_data_url(f_url))
    if b_url:
        content.append(_img_part_from_data_url(b_url))

    resp = client.chat_completions.create(  # .chat.completions.create (alias-safe)
        model=OPENAI_MODEL_GRADE,
        temperature=0.2,
        messages=[
            {"role": "system", "content": system_prompt},
            {"role": "user", "content": content},
        ],
    ) if hasattr(client, "chat_completions") else client.chat.completions.create(
        model=OPENAI_MODEL_GRADE,
        temperature=0.2,
        messages=[
            {"role": "system", "content": system_prompt},
            {"role": "user", "content": content},
        ],
    )

    raw = (resp.choices[0].message.content or "{}").strip()
    try:
        data = json.loads(raw)
    except Exception:
        s, e = raw.find("{"), raw.rfind("}")
        data = json.loads(raw[s:e + 1]) if s != -1 and e != -1 and e > s else {}

    result = _normalize_grade_json(data)
    result = _enforce_observation_guard(result)
    result = _apply_observation_thresholds(result)
    result = _apply_sanity_caps(result)

    # === CV HARD/SOFT RULES (ink/scribble/glare/blur on FRONT) ===
    cv_flags = {}
    try:
        cv_flags = run_vision_checks_img(front_warp_bgr) if front_warp_bgr is not None else {}
    except Exception:
        cv_flags = {}

    scrib = bool(cv_flags.get("scribble"))
    scrib_conf = float(cv_flags.get("scribble_conf", 0.0))

    if scrib and scrib_conf >= 0.88:
        result["scores"]["surface"] = min(result["scores"].get("surface", 10.0), 2.0)
        result["predicted_grade"] = min(result.get("predicted_grade", 10.0), 3.0)
        obs = result.get("observations") or []
        obs.append({
            "category":"surface","side":"front",
            "note":"Detected pen/marker (high confidence CV).","box":[0,0,1,1]
        })
        result["observations"] = obs
    elif scrib and scrib_conf >= 0.55:
        result["scores"]["surface"] = max(0.0, result["scores"].get("surface", 10.0) - 1.0)
        obs = result.get("observations") or []
        obs.append({
            "category":"surface","side":"front",
            "note":"Possible pen/marker (medium confidence CV).","box":[0,0,1,1]
        })
        result["observations"] = obs

    if cv_flags.get("glare"):
        fb = result.get("photo_feedback") or ""
        result["photo_feedback"] = (fb + " Glare detected; results may be conservative.").strip()

    if cv_flags.get("blur"):
        fb = result.get("photo_feedback") or ""
        result["photo_feedback"] = (fb + " Blur detected; results may be conservative.").strip()

    # 5) Optional CV blend (classical model)
    if BLEND_CV_ALPHA > 0.0 and os.path.exists(CV_WEIGHTS) and back_path:
        try:
            from grading.ml.cv_inference import CVGrader
            cv = CVGrader(weights_path=CV_WEIGHTS)
            cv_pred = cv.predict(front_path, back_path)  # dict with keys: centering,...,overall
            a = float(BLEND_CV_ALPHA)
            for k in ["centering", "surface", "edges", "corners", "color"]:
                result["scores"][k] = (1 - a) * result["scores"][k] + a * cv_pred.get(k, 0.0)
            result["predicted_grade"] = (1 - a) * result["predicted_grade"] + a * cv_pred.get("overall", 0.0)
        except Exception:
            pass  # keep LLM-only if CV load/infer fails

    # 6) Attach detected metadata and make label/summary deterministic
    result["detected"] = {
        "set_code": set_info.get("set_code", ""),
        "set_name": set_info.get("set_name", ""),
        "era": set_info.get("era", ""),
        "border": set_info.get("border", ""),
        "language": set_info.get("language", "unknown"),
        "card_name": card_name or "",
        "set_symbol": set_info.get("set_symbol", ""),
        "symbol_conf": float(set_info.get("symbol_conf", 0.0)),
    }
    result = _coerce_label_and_summary(result, cv_flags, result["detected"])

    return result
